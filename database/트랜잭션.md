## Transaction

 - **Transaction 이란**

   DB의 상태를 변환시키는 **하나의 논리적인 작업 단위를 구성하는 연산들의 집합**이다.

   예를 들어, A계좌에서 B계좌로 일정 금액을 이체한다고 가정하자. 이러한 과정은 다음과 같다

   ​	a.  A계좌의 잔액 확인

   ​	b.  A계좌의 금액에서 이체할 금액을 빼고 다시 저장

   ​	c.  B계좌의 잔액을 확인

   ​	d. B계좌의 금액에서 이체할 금액을 더하고 다시 저장

   a~d의 과정들은 모두 합쳐저 계좌이체라는 하나의 작업단위(트랜잭션)을 구성, 트랜잭션은 **항상 all or nothing 원칙을 만족**해야 한다. 즉 완료를 하던가(**commit**) 다시 원래의 상태로 돌아가던가(**rollback**) 둘중 하나는 만족해야 한다. 절대 partoally Done 형태로 끝나서는 안된다.

- **트랜잭션의 성질(ACID)**

  - **Atomicity(원자성) , All or Nothing**

    트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다.

  - **Consistency(일관성)**

    트랜잭션 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 한다. 예를 들어 계좌이체를 성공적으로 실행했다면 A계좌 잔액과 B계좌 잔액의 합이 트랜잭션 실행 전의 합과 동일해야 한다.

  - **Isolation(독립성)**

    하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못한다. DB는 클라이언트들이 같은 데이터를 공유하는 것이 목적이므로 여러 트랜잭션이 동시에 수행된다. 이 때 트랜잭션은 상호 간의 존재를 모르고 독립적으로 수행되어야 한다. 또한 트랜잭션이 실행중인 데이터는 다른 트랜잭션이 동시에 참조하지 못하도록 보장하여야 한다.

  - **Durability(지속성)**

    성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다. 즉 완료된 트랜잭션의 결과는 디스크와 같은 보조기억장치에 저장되거나 시스템 장애가 회복되고 난 후에 어떠한 형태로든지 그 데이터를 복구 할 수 있어야 한다.

- **트랜잭션의 상태**

  ![image-20190720194108374](/Applications/전공정리/데이터베이스/트랜잭션.assets/image-20190720194108374.png)

- **Concurrency Control(동시성 제어)**

  - 2개 이상의 트랜잭션이 하나의 값에 접근하는 경우, 어떤 일이 일어나는지 살펴보자. 두개의 트랜잭션 모두 자원에 대한 읽기만 하는 경우에는 문제가 발생하지 않는다. 그렇다면 1개의 트랜잭션이 쓰기 작업을 진행하는 경우에는 읽기 작업을 진행하는 트랜잭션은 유효하지 않은 데이터를 읽는 문제가 발생 할 수있다. 두개의 트랜잭션 모두 쓰기작업을 진행한다면 아래와 같은 문제점들이 발생 할 수 있다.
  
    - **Lost update(갱신 손실)**
      - 하나의 값에 계속해서 Overwirte하여 데이터의 갱신이 무효화 되는 현상,  초기값 X = 1000이 있고, 트랜잭션 T1은 X +=300, 트랜잭션 T2는 X-=500 이라 할 때, 동시성 제어를 해주지 않으면 1000이라는 값이 T1에 의해 1300이 된 상태에서 T2가 아직 1300으로 Write 되기 전인 X=1000을 Read하여 1300-500이 아니라 1000-500이 수행되어 500을 갖게 되었고 T1과 T2가 순차적으로 값을 저장하여 덮어씌워지는 값의 손실을 갱신손실이라 한다.
    - **Inconsistency(모순성)**
      - 두 개의 트랜잭션이 병행 수행 될 때 원치 않는 자료를 이용함으로써 발생하는 문제
      - 초기값 X=1500, Y=1000이 있고, 트랜잭션 T1은 X와 Y를 300 증가, 트랜잭션 T2는 X와 Y를 3배씩 증가시킨다고 합시다. 트랜잭션 T1이 수행될 때 X와 Y는 각각 1500과 1000이 읽혀야 합니다. T1이 수행되면서 X만을 1800으로 증가시키고 Write된 다음에 Y를 수행하는 것이 아닌 트랜잭션 T2가 수행된다고 합시다. 그러면 T2에 의해 X와 Y는 각각 5400과 3000이 되고 다시 T1의 Y가 Read를 해야하는 상황에서 1000이 아니라 3000이 읽히게 됩니다. 이렇게 **어떤 값은 갱신 전의 값을, 다른 값은 갱신 후의 값을 읽어 데이터가 불일치하는 것을 모순성이라 합니다.** 
    - **Cascading Rollback(연쇄복귀)**
      - 연쇄복귀로, 복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우, 다른 트랜잭션이 처리한 부분에 대해 취소가 불가능한 현상.
      - 트랜잭션 T1이 수행 중인 상태에서 문제가 발생 해 RollBack이 일어 날 때, 해당 자원에 대한 다른 트랜잭션이 처리한 부분이 있어 정상적으로 RollBack이 일어나지 않는 문제이다.
  
    이와 같이 **두개 이상의  트랜잭션이 발생 할 경우 트랜잭션 스케쥴을 이용하거나 Lock이용해 관리한다**.
  
  - **트랜잭션 스케쥴**
    
    - 직렬 스케줄의 경우에는 트랜잭션의 연산을 모두 순차적으로 실행하는 유형, 즉 하나의 트랜잭션이 실행되면 해당 트랜잭션이 완료되어야 다른 트랜잭션이 실행
    - 비직렬 스케쥴은 트랜잭션의 직렬 수행순서와 상관없이 병행 수행하는 스케쥴을 의미
    - 직렬가능 스케쥴은 서로 영향을 주지 않는 직렬 스케줄을 비 직렬적으로 수행
    
- **Lock**
    
    - 여러개의 트랜잭션들이 하나의 자원으로 동시에 접근할 때 이를 제어해주는 도구
    - 락은 읽기를 할 때 사용하는 공유락과 읽고 쓰기를 할 때 사용하는 배타락으로 나뉘어짐
    - 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성이 낮아짐, 작으면 관리가 어렵고 병행성이 높아짐
    - 락이 걸려있는 데이터에 접근하는 트랜잭션은 대기 상태가 된다.
    
  - 다수의 트랜잭션이 동시에 수행되다 보며, **교착상태에 빠질 위험**이 있다. 일반적인 DBMS에서는 교착상태를 검출하여 보고한다. 교착 상태의 빈도를 낮추기 위해서는 트랜잭션을 자주 커밋하고, 정해진 순서로 테이블에 접근 할 수 있도록 하는것이 좋다.
  
  ### Reference
  
  https://limkydev.tistory.com/100
  
  https://mangkyu.tistory.com/30